<?php

namespace WHMCS\Module;

class ModuleEventProcessor
{
    private $module = NULL;

    public function __construct(AbstractModule $module)
    {
        $this->module = $module;
    }

    private function beforeInstallWordPress($params)
    {
        $model = $params["model"];
        if ($model->status !== \WHMCS\Service\Status::ACTIVE) {
            throw new Exception\ModuleFunctionCallAbortedException("Service is not active, cannot install WordPress");
        }
        if (!isset($params["admin_pass"]) || trim($params["admin_pass"]) === "") {
            $params["admin_pass"] = Server::generateRandomPassword();
            $params["admin_pass_autogenerated"] = true;
        }
        return $params;
    }

    public function afterInstallWordPress($params, $callResult)
    {
        $model = $params["model"];
        $instanceUrl = $callResult["protocol"] . "://" . $callResult["domain"] . "/" . $callResult["path"];
        try {
            $emailer = \WHMCS\Mail\Emailer::factoryByTemplate("WordPress Installation Welcome Email", $model->id, ["instance_url" => $instanceUrl, "instance_admin_url" => rtrim($instanceUrl, "/") . "/wp-login.php", "admin_username" => $callResult["username"], "admin_password" => isset($params["admin_pass_autogenerated"]) ? $params["admin_pass"] : "******"]);
            $emailer->send();
        } catch (\Throwable $e) {
            logModuleCall($this->module->getLoadedModule(), "InstallWordPress", $params, "Failed to send WordPress Installation Welcome Email: " . $e->getMessage());
        }
        return $callResult;
    }

    public function beforeFunctionCall($function, $params)
    {
        $methodName = "before" . $function;
        if (method_exists($this, $methodName)) {
            $params = $this->{$methodName}($params);
        }
        return $params;
    }

    public function afterFunctionCall($function, $params, $callResult)
    {
        $methodName = "after" . $function;
        if (method_exists($this, $methodName)) {
            $callResult = $this->{$methodName}($params, $callResult);
        }
        return $callResult;
    }
}
